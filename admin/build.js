const fs = require('fs');
const path = require('path');

const adminDir = __dirname;
const distDir = path.join(adminDir, 'dist');
const sourceHtml = path.join(adminDir, 'index.html');
const targetHtml = path.join(distDir, 'index.html');
const targetEnv = path.join(distDir, 'env.js');

const passthroughKeys = new Set([
  'API_BASE_URL',
  'OIDC_AUTHORIZE_URL',
  'OIDC_TOKEN_URL',
  'OIDC_CLIENT_ID',
  'OIDC_SCOPE',
  'OIDC_AUDIENCE',
  'OIDC_REDIRECT_URI',
]);

const vitePassthroughKeys = new Set([
  'VITE_API_BASE_URL',
  'VITE_API_WEBSOCKET_URL',
  'VITE_TILE_CDN_URL',
  'VITE_MAP_PACKAGE_BASE_URL',
  'VITE_MAP_PACKAGE_INDEX_URL',
  'VITE_MAP_PACKAGE_DOWNLOAD_URL',
  'VITE_MAP_PACKAGE_MANIFEST_URL',
  'VITE_AUTH_DOMAIN',
  'VITE_AUTH_CLIENT_ID',
  'VITE_AUTH_AUDIENCE',
  'VITE_AUTH_SCOPE',
  'VITE_AUTH_REDIRECT_URI',
  'VITE_AUTH_POST_LOGOUT_REDIRECT_URI',
  'VITE_SETTINGS_DEFAULT_REGION',
  'VITE_SETTINGS_DEFAULT_MAP_STYLE',
  'VITE_SETTINGS_FEATURE_FLAGS',
  'VITE_UI_BRAND',
]);

// Secrets that should never be exported to window.* even if present in the .env
const maskedKeys = new Set([
  'OIDC_CLIENT_SECRET',
  'VITE_AUTH_CLIENT_SECRET',
]);

const requiredKeys = [
  'VITE_API_BASE_URL',
  'VITE_TILE_CDN_URL',
  'VITE_MAP_PACKAGE_BASE_URL',
  'VITE_MAP_PACKAGE_INDEX_URL',
  'VITE_MAP_PACKAGE_DOWNLOAD_URL',
  'VITE_MAP_PACKAGE_MANIFEST_URL',
  'VITE_SETTINGS_DEFAULT_REGION',
  'VITE_SETTINGS_DEFAULT_MAP_STYLE',
  'VITE_SETTINGS_FEATURE_FLAGS',
  'VITE_AUTH_DOMAIN',
  'VITE_AUTH_CLIENT_ID',
  'VITE_AUTH_AUDIENCE',
  'VITE_AUTH_SCOPE',
  'VITE_AUTH_REDIRECT_URI',
  'VITE_AUTH_POST_LOGOUT_REDIRECT_URI',
  'OIDC_AUTHORIZE_URL',
  'OIDC_TOKEN_URL',
  'OIDC_CLIENT_ID',
  'OIDC_SCOPE',
  'OIDC_REDIRECT_URI',
];

function parseEnvFile(filePath) {
  if (!fs.existsSync(filePath)) return {};
  const content = fs.readFileSync(filePath, 'utf8');
  return content.split(/\r?\n/).reduce((acc, line) => {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith('#')) return acc;
    const equalsIndex = trimmed.indexOf('=');
    if (equalsIndex === -1) return acc;
    const key = trimmed.slice(0, equalsIndex).trim();
    let value = trimmed.slice(equalsIndex + 1).trim();
    if (
      (value.startsWith('"') && value.endsWith('"')) ||
      (value.startsWith("'") && value.endsWith("'"))
    ) {
      value = value.slice(1, -1);
    }
    acc[key] = value;
    return acc;
  }, {});
}

function loadEnvValues() {
  return [path.join(adminDir, '.env'), path.join(adminDir, '.env.local')]
    .filter((filePath) => fs.existsSync(filePath))
    .reduce((acc, filePath) => ({ ...acc, ...parseEnvFile(filePath) }), {});
}

function validateEnvValues(envValues) {
  const missingRequired = requiredKeys.filter(
    (key) => envValues[key] === undefined || envValues[key].trim() === ''
  );

  const disallowed = Object.keys(envValues).filter(
    (key) =>
      !passthroughKeys.has(key) &&
      !vitePassthroughKeys.has(key) &&
      !maskedKeys.has(key)
  );

  if (missingRequired.length > 0) {
    const message = [
      'Eksik/boş zorunlu ortam değişkenleri bulundu:',
      ...missingRequired.map((key) => `  - ${key}`),
      '',
      'admin/.env (veya admin/.env.local) dosyalarındaki değerleri kontrol edip tekrar deneyin.',
    ].join('\n');
    throw new Error(message);
  }

  if (disallowed.length > 0) {
    console.warn(
      'Allowlist dışında kalan anahtarlar bulundu ve yoksayıldı:\n' +
        disallowed.map((key) => `  - ${key}`).join('\n')
    );
  }

  const maskedPresent = [...maskedKeys].filter((key) => envValues[key]);
  if (maskedPresent.length > 0) {
    console.warn(
      'Gizli kalması gereken anahtarlar tespit edildi ve window.* çıktısına eklenmedi:\n' +
        maskedPresent.map((key) => `  - ${key} (maskelendi)`).join('\n')
    );
  }
}

function collectWindowConfig(allEnv) {
  return Object.entries(allEnv).reduce((acc, [key, value]) => {
    if (value === undefined) return acc;
    if (maskedKeys.has(key)) return acc;
    if (vitePassthroughKeys.has(key)) {
      acc[key.replace(/^VITE_/, '')] = value;
      return acc;
    }
    if (passthroughKeys.has(key)) {
      acc[key] = value;
    }
    return acc;
  }, {});
}

function writeEnvScript(config) {
  const assignments = Object.entries(config)
    .map(([key, value]) => `  window.${key} = ${JSON.stringify(value)};`)
    .join('\n');
  const output = `// Auto-generated by admin/build.js\n(function() {\n${assignments}\n})();\n`;
  fs.writeFileSync(targetEnv, output, 'utf8');
}

function ensureDist() {
  if (!fs.existsSync(distDir)) fs.mkdirSync(distDir, { recursive: true });
}

function copyIndex() {
  fs.copyFileSync(sourceHtml, targetHtml);
}

function build() {
  ensureDist();
  copyIndex();
  const envValues = loadEnvValues();
  validateEnvValues(envValues);
  const windowValues = collectWindowConfig(envValues);
  writeEnvScript(windowValues);
  console.log(`Admin build completed. ${Object.keys(windowValues).length} environment value(s) exported to window.*`);
  console.log(`Output directory: ${distDir}`);
}

build();
