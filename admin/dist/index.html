<!doctype html>
<html lang="tr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ayarlar</title>
    <style>
      body { font-family: Arial, sans-serif; padding: 2rem; background: #f5f5f5; }
      form, table { background: #fff; padding: 1rem; border-radius: 8px; }
      table { width: 100%; border-collapse: collapse; margin-top: 1rem; }
      th, td { padding: 0.5rem; border-bottom: 1px solid #ddd; }
      .actions button { margin-right: 0.5rem; }
      .status { margin-bottom: 1rem; }
      .pill {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 12px;
        background: #555;
        color: #fff;
        font-size: 0.85rem;
      }
    </style>
  </head>
  <body>
    <h1>Ayarlar</h1>
    <div class="status" id="status"></div>
    <section class="auth">
      <h2>Giriş</h2>
      <form id="login-form">
        <label>Authorization URL: <input name="authorizeUrl" required /></label>
        <label>Token URL: <input name="tokenUrl" required /></label>
        <label>Redirect URI: <input name="redirectUri" required /></label>
        <label>İstemci ID: <input name="clientId" required /></label>
        <label>Scope: <input name="scope" value="openid profile email offline_access" /></label>
        <label>Audience: <input name="audience" placeholder="opsiyonel" /></label>
        <button type="submit">Hosted girişe git</button>
      </form>
      <button id="logout-btn" type="button">Çıkış</button>
    </section>
    <form id="settings-form">
      <label>Key: <input name="key" required /></label>
      <label>Value: <input name="value" required /></label>
      <label>Description: <input name="description" /></label>
      <label><input type="checkbox" name="secret" /> Gizli alan</label>
      <button type="submit">Kaydet</button>
    </form>

    <table>
      <thead>
        <tr><th>Key</th><th>Value</th><th>Gizli?</th><th>Description</th><th>Güncellendi</th><th>Actions</th></tr>
      </thead>
      <tbody id="settings-body"></tbody>
    </table>

    <script src="./env.js"></script>
    <script>
      const apiBase = (window.API_BASE_URL || '') + '/api/settings';
      const statusEl = document.getElementById('status');
      const form = document.getElementById('settings-form');
      const bodyEl = document.getElementById('settings-body');
      const loginForm = document.getElementById('login-form');
      const logoutBtn = document.getElementById('logout-btn');
      const configStorageKey = 'settingsAuthConfig';
      const pkceStorageKey = 'settingsPkceState';
      const legacyTokenStorageKey = 'settingsTokens';
      const defaultConfig = {
        authorizeUrl: window.OIDC_AUTHORIZE_URL || '',
        tokenUrl: window.OIDC_TOKEN_URL || '',
        clientId: window.OIDC_CLIENT_ID || '',
        scope: window.OIDC_SCOPE || 'openid profile email offline_access',
        audience: window.OIDC_AUDIENCE || '',
        redirectUri: window.OIDC_REDIRECT_URI || `${window.location.origin}${window.location.pathname}`,
      };
      let authConfig = loadConfig();
      let tokens = null;

      function loadConfig() {
        try {
          const stored = JSON.parse(localStorage.getItem(configStorageKey)) || {};
          const { username: _legacyUsername, password: _legacyPassword, ...rest } = stored;
          const merged = { ...defaultConfig, ...rest };
          localStorage.setItem(configStorageKey, JSON.stringify(merged));
          return merged;
        } catch (error) {
          console.error('config parse error', error);
          return { ...defaultConfig };
        }
      }

      function saveConfig(config) {
        authConfig = { ...authConfig, ...config };
        localStorage.setItem(configStorageKey, JSON.stringify(authConfig));
      }

      function clearLegacyStorage() {
        localStorage.removeItem(legacyTokenStorageKey);
        const stored = JSON.parse(localStorage.getItem(configStorageKey) || '{}');
        if (stored.username || stored.password) {
          const { username: _legacyUsername, password: _legacyPassword, ...rest } = stored;
          localStorage.setItem(configStorageKey, JSON.stringify(rest));
        }
      }

      function persistTokens(newTokens) {
        if (!newTokens) {
          tokens = null;
          return;
        }
        const expiresInMs = newTokens.expires_in ? newTokens.expires_in * 1000 : null;
        const expiresAt = expiresInMs ? Date.now() + expiresInMs : null;
        tokens = { ...newTokens, expiresAt };
      }

      function isTokenExpired(currentTokens) {
        if (!currentTokens || !currentTokens.expiresAt) return false;
        return Date.now() >= currentTokens.expiresAt - 15_000;
      }

      function status(text, isError) {
        statusEl.textContent = text;
        statusEl.style.color = isError ? 'red' : 'inherit';
      }

      function base64UrlEncode(buffer) {
        const binary = String.fromCharCode(...new Uint8Array(buffer));
        return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
      }

      function randomString(length = 64) {
        const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
        const array = new Uint8Array(length);
        crypto.getRandomValues(array);
        return Array.from(array, (byte) => charset[byte % charset.length]).join('');
      }

      async function generateCodeChallenge(verifier) {
        const data = new TextEncoder().encode(verifier);
        const digest = await crypto.subtle.digest('SHA-256', data);
        return base64UrlEncode(digest);
      }

      function storePkceState(value) {
        sessionStorage.setItem(pkceStorageKey, JSON.stringify(value));
      }

      function loadPkceState() {
        try {
          return JSON.parse(sessionStorage.getItem(pkceStorageKey) || 'null');
        } catch (error) {
          console.error('pkce parse error', error);
          return null;
        }
      }

      function clearPkceState() {
        sessionStorage.removeItem(pkceStorageKey);
      }

      async function startAuthorization(config) {
        if (!config.authorizeUrl || !config.tokenUrl) {
          throw new Error('Authorization veya token endpoint ayarlarını doldurun.');
        }
        const codeVerifier = randomString(64);
        const codeChallenge = await generateCodeChallenge(codeVerifier);
        const state = randomString(32);
        storePkceState({ codeVerifier, state });
        saveConfig(config);

        const authorizeUrl = new URL(config.authorizeUrl);
        authorizeUrl.searchParams.set('response_type', 'code');
        authorizeUrl.searchParams.set('client_id', config.clientId);
        authorizeUrl.searchParams.set('redirect_uri', config.redirectUri);
        authorizeUrl.searchParams.set('scope', config.scope);
        authorizeUrl.searchParams.set('code_challenge', codeChallenge);
        authorizeUrl.searchParams.set('code_challenge_method', 'S256');
        authorizeUrl.searchParams.set('state', state);
        if (config.audience) authorizeUrl.searchParams.set('audience', config.audience);
        status('Kimlik doğrulama için yönlendiriliyorsunuz...');
        window.location.assign(authorizeUrl.toString());
      }

      async function exchangeAuthCode(code, codeVerifier) {
        if (!codeVerifier) throw new Error('PKCE doğrulama verisi bulunamadı.');
        const body = new URLSearchParams({
          grant_type: 'authorization_code',
          code,
          redirect_uri: authConfig.redirectUri,
          client_id: authConfig.clientId,
          code_verifier: codeVerifier,
        });
        if (authConfig.audience) body.append('audience', authConfig.audience);
        const res = await fetch(authConfig.tokenUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body,
        });
        if (!res.ok) throw new Error('Giriş başarısız');
        const data = await res.json();
        persistTokens(data);
        status('Giriş tamamlandı.');
      }

      async function refreshAccessToken() {
        if (!tokens?.refresh_token) throw new Error('Yenileme tokenı bulunamadı');
        const body = new URLSearchParams({
          grant_type: 'refresh_token',
          refresh_token: tokens.refresh_token,
          client_id: authConfig.clientId,
          scope: authConfig.scope,
        });
        if (authConfig.audience) body.append('audience', authConfig.audience);
        const res = await fetch(authConfig.tokenUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body,
        });
        if (!res.ok) throw new Error('Token yenileme başarısız');
        const data = await res.json();
        persistTokens({ ...tokens, ...data });
        status('Access token yenilendi.');
      }

      async function ensureAccessToken() {
        if (tokens && !isTokenExpired(tokens)) return tokens.access_token;
        if (tokens?.refresh_token) {
          await refreshAccessToken();
          return tokens.access_token;
        }
        throw new Error('Giriş gerekli');
      }

      async function authorizedFetch(url, options = {}) {
        const headers = new Headers(options.headers || {});
        const token = await ensureAccessToken();
        headers.set('Authorization', `Bearer ${token}`);
        const requestOptions = { ...options, headers };

        let response = await fetch(url, requestOptions);
        if (response.status === 401 && tokens?.refresh_token) {
          await refreshAccessToken();
          headers.set('Authorization', `Bearer ${tokens.access_token}`);
          response = await fetch(url, { ...options, headers });
        }
        if (response.status === 401) throw new Error('Kimlik doğrulama başarısız');
        return response;
      }

      async function fetchSettings() {
        status('Yükleniyor...');
        const res = await authorizedFetch(apiBase);
        const data = await res.json();
        renderTable(data.settings || []);
        status('Kaydedilmiş ayarlar yüklendi.');
      }

      function renderTable(settings) {
        bodyEl.innerHTML = '';
        settings.forEach((item) => {
          const row = document.createElement('tr');
          const keyCell = document.createElement('td');
          keyCell.textContent = item.key;

          const valueCell = document.createElement('td');
          if (item.masked) {
            const pill = document.createElement('span');
            pill.className = 'pill';
            pill.textContent = 'gizli';
            valueCell.appendChild(pill);
          } else {
            valueCell.textContent = item.value;
          }

          const secretCell = document.createElement('td');
          secretCell.textContent = item.masked ? 'Evet' : 'Hayır';

          const descCell = document.createElement('td');
          descCell.textContent = item.description || '';

          const updatedCell = document.createElement('td');
          updatedCell.textContent = item.updatedAt || '';

          const actionsCell = document.createElement('td');
          actionsCell.className = 'actions';
          const editBtn = document.createElement('button');
          editBtn.dataset.action = 'edit';
          editBtn.textContent = 'Düzenle';
          const deleteBtn = document.createElement('button');
          deleteBtn.dataset.action = 'delete';
          deleteBtn.textContent = 'Sil';
          actionsCell.appendChild(editBtn);
          actionsCell.appendChild(deleteBtn);

          row.appendChild(keyCell);
          row.appendChild(valueCell);
          row.appendChild(secretCell);
          row.appendChild(descCell);
          row.appendChild(updatedCell);
          row.appendChild(actionsCell);
          row.dataset.id = item.id;
          row.dataset.masked = item.masked;
          row.dataset.secret = item.secret;
          bodyEl.appendChild(row);
        });
      }

      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        const formData = new FormData(form);
        const existingRow = bodyEl.querySelector('tr[data-editing="true"]');
        const payload = {
          key: (formData.get('key') || '').trim(),
          value: (formData.get('value') || '').trim(),
          description: (formData.get('description') || '').trim(),
          secret: form.secret.checked,
        };

        if (!payload.description) delete payload.description;
        if (existingRow && !payload.value) delete payload.value;
        if (!existingRow && !payload.value) {
          status('Value zorunludur', true);
          return;
        }

        const method = existingRow ? 'PUT' : 'POST';
        const targetId = existingRow ? existingRow.dataset.id : '';
        try {
          const res = await authorizedFetch(`${apiBase}/${targetId}`, {
            method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          if (!res.ok) {
            const err = await res.json();
            status(err.message || 'Hata oluştu', true);
            return;
          }
          form.reset();
          form.value.placeholder = '';
          form.secret.checked = false;
          if (existingRow) existingRow.removeAttribute('data-editing');
          await fetchSettings();
        } catch (error) {
          status(error.message || 'Hata oluştu', true);
        }
      });

      bodyEl.addEventListener('click', async (e) => {
        const action = e.target.dataset.action;
        if (!action) return;
        const row = e.target.closest('tr');
        const id = row.dataset.id;
        if (action === 'delete') {
          if (!confirm('Ayarı sil ve türev artefaktları temizle?')) return;
          try {
            const res = await authorizedFetch(`${apiBase}/${id}`, { method: 'DELETE' });
            if (!res.ok) {
              status('Silme başarısız', true);
              return;
            }
            await fetchSettings();
            return;
          } catch (error) {
            status(error.message || 'Silme başarısız', true);
            return;
          }
        }
        if (action === 'edit') {
          row.dataset.editing = 'true';
          form.key.value = row.children[0].textContent;
          form.description.value = row.children[3].textContent;
          form.secret.checked = row.dataset.secret === 'true';
          if (row.dataset.masked === 'true') {
            form.value.value = '';
            form.value.placeholder = 'Yeni değer girin';
          } else {
            form.value.value = row.children[1].textContent;
            form.value.placeholder = '';
          }
          status('Düzenleme modunda');
        }
      });

      loginForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const payload = Object.fromEntries(new FormData(loginForm).entries());
        try {
          await startAuthorization(payload);
        } catch (error) {
          status(error.message || 'Giriş başlatılamadı', true);
        }
      });

      logoutBtn.addEventListener('click', () => {
        persistTokens(null);
        clearPkceState();
        status('Oturum kapatıldı.');
      });

      function prefillLoginForm() {
        const config = loadConfig();
        authConfig = config;
        Object.entries(config).forEach(([key, value]) => {
          if (loginForm[key]) loginForm[key].value = value || '';
        });
      }

      async function handleRedirectCallback() {
        const params = new URLSearchParams(window.location.search);
        const error = params.get('error');
        if (error) {
          status(params.get('error_description') || error, true);
          clearPkceState();
          window.history.replaceState({}, document.title, window.location.pathname);
          return true;
        }
        const code = params.get('code');
        const state = params.get('state');
        if (!code) return false;
        const pkceState = loadPkceState();
        if (!pkceState || pkceState.state !== state) {
          status('PKCE state doğrulanamadı.', true);
          clearPkceState();
          window.history.replaceState({}, document.title, window.location.pathname);
          return true;
        }
        try {
          await exchangeAuthCode(code, pkceState.codeVerifier);
          window.history.replaceState({}, document.title, window.location.pathname);
          clearPkceState();
          await fetchSettings();
        } catch (err) {
          status(err.message || 'Giriş başarısız', true);
        }
        return true;
      }

      async function boot() {
        clearLegacyStorage();
        prefillLoginForm();
        try {
          const handled = await handleRedirectCallback();
          if (!handled) status('Lütfen giriş yapın.');
        } catch (error) {
          status(error.message || 'Yüklenemedi', true);
        }
      }

      boot();
    </script>
  </body>
</html>
